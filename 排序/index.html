<!--
 * @Author: 杨宏旋
 * @Date: 2020-01-08 17:34:21
 * @LastEditors  : 杨宏旋
 * @LastEditTime : 2020-01-19 10:17:13
 * @Description:快速排序
 -->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>快速排序</title>
</head>

<body>

</body>

</html>
<script type="module">
  import Stack from '../tools/Stack.js'
  class  SortMethods extends Stack{
    bubbleSort() {
      // 通过相邻元素的比较和交换，使得每一趟循环都能找到未有序数组的最大值或最小值。
      // 记录length
      let length = this.items.length;
      // 数组不存在判断
      if (!length) {
        console.error('数组不存在判断 ');
        return [];
      }
      for (let i = 0; i < length; i++) {
        for (let j = 0; j < length - i - 1; j++) {
          if (this.items[j] > this.items[j + 1]) {
            [this.items[j], this.items[j + 1]] = [this.items[j + 1],this.items[j]];
          }
        }
        console.log(`第${i+1}次循环`, this.items);
      }
    }
    bubbleSortOptimization() {
      // 标记在一轮比较汇总中，如果没有需要交换的数据，说明数组已经有序，可以减少排序循环的次数。
      // 记录length
      let length = this.items.length;
      // 数组不存在判断
      if (!length) {
        console.error('数组不存在判断 ');
        return [];
      }
      for (let i = 0; i < length; i++) {
        let mark = true; // 如果在一轮比较中没有出现需要交互的数据，说明数组已经有序，
        for (let j = 0; j < length - i - 1; j++) {
          if (this.items[j] > this.items[j + 1]) {
            [this.items[j], this.items[j + 1]] = [this.items[j + 1],this.items[j]];
            mark = false;
          }
        }
        console.log(`第${i+1}次循环`, this.items);
        if (mark) return;
      }
      console.log(111);
    }
    bubbleSortTow(){
      let low = 0;
      let high = this.items.length - 1;
      while (low < high) {
        let mark = true;
        // 找到最大值放到右边
        for (let i = low; i < high; i++) {
          if (this.items[i] > this.items[i + 1]) {
            [this.items[i], this.items[i + 1]] = [this.items[i + 1], this.items[i]];
            mark = false;
          }
        }
        high--;
        // 找到最小值放到左边
        for (let j = high; j > low; j--) {
          if (this.items[j] < this.items[j - 1]) {
            [this.items[j], this.items[j - 1]] = [this.items[j - 1], this.items[j]];
            mark = false;
          }
        }
        low++;
        console.log(mark);
        console.log(`第${low}次循环`, this.items);
        if (mark) return this.items;
      }
    }
  }
  let s = new SortMethods()
  s.push(12)
  s.push(641)
  s.push(712)
  s.push(4423)
  s.push(5432)
  s.push(58)
  s.push(9423)
  s.push(423)
  s.push(2523)
  s.push(3)
  console.log(s.toString());
  // console.time();
  // s.bubbleSort()
  // console.timeEnd();
  // console.time();
  // s.bubbleSortOptimization()
  // console.timeEnd();
  console.time();
  s.bubbleSortTow()
  console.timeEnd();

</script>
