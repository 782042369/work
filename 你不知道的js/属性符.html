<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>

</body>

</html>
<script>
  // var myObject = {
  //   a: 2
  // };
  // Object.getOwnPropertyDescriptor(myObject, "a");
  // console.log('Object.getOwnPropertyDescriptor(myObject, "a");: ',
  //   Object.getOwnPropertyDescriptor(myObject, "a")
  // );
  // writable(可写)、 enumerable(可枚举) 和 configurable(可配置)
  /*Writable***********************/
  // var myObject = {};
  // Object.defineProperty(myObject, "a", {
  //   value: 2,
  //   writable: false, // 不可写! 
  //   configurable: true,
  //   enumerable: true
  // });
  // myObject.a = 3;
  // console.log('myObject: ', myObject);
  /*Writable***********************/
  // "use strict";
  // var myObject = {};
  // Object.defineProperty(myObject, "a", {
  //   value: 2,
  //   writable: false, // 不可写! 
  //   configurable: true,
  //   enumerable: true
  // });
  // myObject.a = 3; // TypeError
  // TypeError 错误表示我们无法修改一个不可写的属性。
  /*Configurable***********************/
  // var myObject = {
  //   a: 2
  // };
  // myObject.a = 3;
  // myObject.a; // 3
  // Object.defineProperty(myObject, "a", {
  //   value: 4,
  //   writable: true,
  //   configurable: false, // 不可配置!
  //   enumerable: true
  // });
  // myObject.a; // 4
  // myObject.a = 5;
  // myObject.a; // 5
  // Object.defineProperty(myObject, "a", {
  //   value: 6,
  //   writable: true,
  //   configurable: true,
  //   enumerable: true
  // }); // TypeError 把 configurable 修改成 false 是单向操作，无法撤销!
  // 要注意有一个小小的例外:即便属性是 configurable:false，我们还是可以 把 writable 的状态由 true 改为 false，但是无法由 false 改为 true。
  /*Configurable***********************/
  // configurable:false 还会禁止删除这个属性:
  // var myObject = {
  //   a: 2
  // };
  // myObject.a; // 2
  // delete myObject.a;
  // myObject.a; // undefined
  // Object.defineProperty(myObject, "a", {
  //   value: 2,
  //   writable: true,
  //   configurable: false,
  //   enumerable: true
  // });
  // myObject.a; // 2 
  // delete myObject.a;
  // myObject.a; // 2
  /*in * hasOwnProperty**********************/
  // var myObject = {
  //   a: 2
  // };
  // console.log("a" in myObject); // true
  // console.log("b" in myObject); // false
  // console.log(myObject.hasOwnProperty("a")); // true
  // console.log(myObject.hasOwnProperty("b")); // false
  /*enumerable***********************/
  var myObject = {};
  Object.defineProperty(myObject, "a", {
    enumerable: true,
    value: 2
  }); // 让 a 像普通属性一样可以枚举 
  Object.defineProperty(myObject, "b", {
    enumerable: false,
    value: 3
  }); // 让b不可枚举
  console.log(myObject.b); // 3
  console.log("b" in myObject); // true 
  myObject.hasOwnProperty("b"); // true
  for (var k in myObject) {
    console.log(k, myObject[k]);
  }
  console.log(myObject.propertyIsEnumerable("a")); // true
  console.log(myObject.propertyIsEnumerable("b")); // false
  console.log(Object.keys(myObject)); // ["a"]
  console.log(Object.getOwnPropertyNames(myObject)); // ["a", "b"]
  // propertyIsEnumerable(..) 会检查给定的属性名是否直接存在于对象中(而不是在原型链 上)并且满足 enumerable:true。
  // Object.keys(..) 会返回一个数组，包含所有可枚举属性，Object.getOwnPropertyNames(..) 会返回一个数组，包含所有属性，无论它们是否可枚举。
  // in 和 hasOwnProperty(..) 的区别在于是否查找 [[Prototype]] 链，然而，Object.keys(..) 和 Object.getOwnPropertyNames(..) 都只会查找对象直接包含的属性。
  // "a" 2
</script>
