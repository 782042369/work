<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>

</body>

</html>
<script>
  // var obj = {
  //   id: "awesome",
  //   cool: function coolFn() {
  //     console.log(this.id)
  //   }
  // };
  // var id = "not awesome"
  // obj.cool(); // 酷
  // setTimeout(obj.cool, 100); // 不酷
  /************************/

  // function identify() {
  //   return this.name.toUpperCase();
  // }

  // function speak() {
  //   var greeting = "Hello, I'm " + identify.call(this);
  //   console.log(greeting);
  // }
  // var me = {
  //   name: "Kyle"
  // };
  // var you = {
  //   name: "Reader"
  // };
  // identify.call(me); // KYLE
  // identify.call(you); // READER
  // speak.call(me); // Hello, 我是 KYLE speak.call( you ); // Hello, 我是 READER
  /************************/
  // function foo(num) {
  //   console.log("foo: ", num);
  //   // 记录 foo 被调用的次数
  //   // 注意，在当前的调用方式下(参见下方代码)，this 确实指向 foo 
  //   this.count++;
  // }
  // foo.count = 0;
  // for (var i = 0; i < 10; i++) {
  //   if (i > 5) {
  //     // 使用 call(..) 可以确保 this 指向函数对象 foo 本身
  //     foo.call(foo, i);
  //   }
  // }
  // console.log('foo.count: ', foo.count);
  /************************/
  // function foo() {
  //   console.log(this.a);
  // }
  // function doFoo(fn) {
  //   console.log('fn: ', fn);
  //   // fn 其实引用的是 foo 
  //   fn(); // <-- 调用位置!
  // }
  // var obj = {
  //   a: 2,
  //   foo: foo
  // };
  // var a = "oops, global"; // a 是全局对象的属性 
  // doFoo(obj.foo); // "oops, global"

  // var obj = {
  //   a: 2,
  //   foo: foo
  // };
  // var bar = obj; // 函数别名!
  // var a = "oops, global"; // a 是全局对象的属性 
  // // bar.foo();
  // bar = obj.foo;
  // bar()

  // var obj = {
  //   a: 2,
  //   foo: foo
  // };
  // var a = "oops, global"; // a 是全局对象的属性
  // setTimeout(obj.foo, 100); // "oops, global"
  // // setTimeout() 函数实现和下面的伪代码类似:
  // function setTimeout(fn, delay) { // 等待 delay 毫秒
  //   fn(); // <-- 调用位置!
  // }
  /************************/
  // function foo() {
  //   console.log(this.a);
  // }
  // var obj = {
  //   a: 2
  // };
  // foo.call(obj); // 2
  /************************/

  // function foo() {
  //   console.log(this.a);
  // }
  // var obj = {
  //   a: 2
  // };
  // var bar = function () {
  //   foo.call(obj);
  // };
  // bar(); // 2
  // setTimeout(bar, 100); // 2
  // 硬绑定的 bar 不可能再修改它的 this 
  // bar.call(window); // 2
  /************************/

  // function foo(something) {
  //   console.log(this.a, something);
  //   return this.a + something;
  // }
  // var obj = {
  //   a: 2
  // };
  // var bar = function () {
  //   return foo.apply(obj, arguments);
  // };
  // var b = bar(3); // 2 3 
  // console.log(b); // 5
  /************************/

  // function foo(el) {
  //   console.log(el, this.id);
  // }
  // var obj = {
  //   id: "awesome"
  // };
  // [1, 2, 3].forEach(foo, obj);
  // 调用 foo(..) 时把 this 绑定到 obj 
  // 1 awesome 2 awesome 3 awesome

  function foo() {
    var a = 2;
    this.bar();
  }

  function bar() {
    console.log(this.a);
  }
  foo(); // ReferenceError: a is not defined
</script>
